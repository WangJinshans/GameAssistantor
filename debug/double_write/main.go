package doublewrite

// 延时双删: https://www.51cto.com/article/705360.html
// 1. 先写入缓存再写入数据库  如果是两个写程序 第一个先写入缓存成功后写入数据库的时候网络延迟, 第二个写入缓存成功后也更新了数据库, 此时第一个程序再更新数据库, 那么数据库是旧数据, 缓存是新数据
// 2. 先写入数据库在写入缓存  如果是两个写程序 第一个在写入数据库成功后写入缓存的时候网络延迟, 第二个写入数据库成功后也更新了缓存, 此时第一个程序再更新缓存, 那么缓存将是旧数据, 数据库是新数据
// 3. 先删除缓存在写入数据库  如果是两个写程序 第一个删除成功后写入时网络延迟, 第二个写入成功, 第一个程序才开始写入, 那么数据库会被覆盖成旧值, 如果一写一读, 写的程序在写入数据库是延迟, 读的请求把旧值更新到缓存后, 写程序才更新数据库
// 4. 先写入数据库, 再删除缓存 两个写程序同时进行没什么问题, 一读一写也没什么问题, 只读了一次旧数据, 但是如果读取缓存发现没有数据, 更新到缓存的过程中出现网络延迟
//    如果读请求先到, 并更新缓存的时候延迟了, 那么写请求先更新数据库后删除了缓存, 再执行读请求的更新操作, 缓存将是旧值
// 5. 延时双删: 多个写请求没有问题, 两个写请求, 一个读请求, 写请求只有写入数据库, 数据不存在一致问题,
// 	  读请求只有更新缓存的时候有网络延时影响, 查询延时读取的数据都是新数据, 只有读取了老数据并且写入缓存的时候延迟了才会出现问题, 这个时候如果已经更新了多次数据, 只要保证删除这个读请求延时导致的脏数据即可, 也就是一个读请求的业务耗时
//    这也是为什么要延迟删除的原因
