
内存泄漏:(内存未被释放)
1. 全局变量，全局变量在整个程序运行期间都一直存在，如果不断向全局变量中添加数据而不进行清理，将会占用越来越多的内存。
2. goroutine 泄漏，在 Golang 中，启动的 goroutine 如果没有正确的退出机制，将会一直存在，占用的内存也不会被释放，如果类似的 goroutine 越来越多，就会导致内存泄露。
3. 未关闭的资源，如果没有关闭文件句柄、网络连接等资源，也会导致内存泄漏。
4. 循环引用, 当两个或多个对象互相引用, 形成循环引用时, 即使它们都不再被其他代码所引用, GC 也无法确定哪些对象应该被回收。
5. 不合理的缓存, 不合理的缓存策略可能导致缓存占用的内存无限增长。
6. C语言接口(Cgo), 在使用 Cgo 与 C 语言库交互时，需要手动管理内存，如果没有做好分配或释放内存策略，也可能会导致内存泄漏。
7. 闭包引用外部作用域变量，如果在闭包中引用了外部作用域的变量，可能导致闭包在执行时一直持有该变量的引用，从而引发内存泄漏。
8. 不恰当的内存池使用，内存池(如 sync.Pool)如果使用不当, 可能会导致内存泄漏。例如，如果池中的对象持有对其他大型数据结构的引用，这些数据结构可能不会被及时回收。
9. 监听器和回调函数未注销，如果不再需要事件监听器或回调函数，但没有从注册它们的对象中注销，可能会继续占用内存。
10.channel 泄漏：如果一个 channel 没有被关闭，而且持续有数据发送到这个 channel, 但没有 goroutine 在接收，也会导致内存泄漏。

逃逸分析: 
go build -gcflags=-m main.go   

反汇编: 
go build -gcflags="all=-N -l" -o main main.go
go tool objdump -s "main.main" main

性能分析: pprof, 火焰图

